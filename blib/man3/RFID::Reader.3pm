.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Reader 3"
.TH Reader 3 "2004-04-05" "perl v5.8.1" "User Contributed Perl Documentation"
.SH "NAME"
RFID::Reader \- Perl interface to the RFID 13.56 MHz ISO15693\-Reader shipped by Megaset Systemtechnik
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use RFID::Reader;
\&  use RFID::Transponder;
\&  use Time::HiRes qw(usleep);
.Ve
.PP
.Vb 4
\&  # new read object
\&  my $reader = RFID::Reader->new( serial_device => '/dev/cuaa0',
\&                                  serial_speed => 19200)  
\&    or die "can't initialize";
.Ve
.PP
.Vb 1
\&  my $card;
.Ve
.PP
.Vb 5
\&  # wait for card
\&  while(not ref $card) {
\&    $card = $reader->iso_inventory($config, 0, $len, $mask);
\&    usleep(300);
\&  }
.Ve
.PP
.Vb 3
\&  # read transponder information
\&  $reader->iso_get_system_information($card) or
\&    die "can't get system information: ". $reader->get_last_error_msg();
.Ve
.PP
.Vb 6
\&  # print afi if feature_available
\&  if($card->afi_available()) {
\&    print 
\&        "afi         : ", $card->get_afi(), "\en",
\&        "description : ", $card->get_afi_descr(), "\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\fBnew( <config_hash>)\fR" 4
.IX Item "new( <config_hash>)"
initializes a serial connection to controller, reads controller state.
if controller is in continuous mode, it will be switched of.
transponder will be enabled. the constructor returns undef on failure.
.Sp
possible keys are:
.RS 4
.Sp
.RS 4
\&\fBserial_device\fR the serial device name
.Sp
\&\fBserial_speed\fR serial line speed. possible values are 9600 
and 19200 baud. (def.: 19200)
.Sp
\&\fBdebug\fR enables debugging mode. commands to and responses from
controller are printet to stdout.
.Sp
\&\fBdevice_address\fR is the controller address. it is used in serial bus systems.
each controller has a three digit id. if param is undefined, the controller
address will be probed.
.RE
.RE
.RS 4
.RE
.IP "\fB\f(BIget_last_error()\fB\fR" 4
.IX Item "get_last_error()"
.PD 0
.IP "\fB\f(BIget_last_error_msg()\fB\fR" 4
.IX Item "get_last_error_msg()"
.PD
if controller command failure occures, the error state is
saved. to poll error status use methods above. \fB\f(BIget_last_error()\fB\fR
returns err-flag as received from controller. human readable
error messages are returned by \fB\f(BIget_last_error_msg()\fB\fR.
.IP "\fB\f(BIget_controller_address()\fB\fR" 4
.IX Item "get_controller_address()"
returns controllers current address.
.IP "\fB\f(BIget_continuous_state()\fB\fR" 4
.IX Item "get_continuous_state()"
returns true if controller is in continuous mode.
.Sh "\s-1CONTROLLER\s0 \s-1RELATED\s0 \s-1FUNCTIONS\s0"
.IX Subsection "CONTROLLER RELATED FUNCTIONS"
.IP "\fB\f(BIread_device_info()\fB\fR" 4
.IX Item "read_device_info()"
returns basic product information as hash reference or undef on failure.
possible keys are:
.RS 4
.Sp
.RS 4
\&\fBdevice_address\fR
.Sp
\&\fBhardware_version\fR
.Sp
\&\fBsoftware_version\fR
.Sp
\&\fBsoftware_date\fR
.Sp
\&\fBproduct_name\fR
.Sp
\&\fBfirmware_build\fR
.RE
.RE
.RS 4
.RE
.IP "\fBswitch_led( <led_num>, <new_state>)\fR" 4
.IX Item "switch_led( <led_num>, <new_state>)"
controller has a red (3), yellow (2) and a green (1) led.
you can switch off (0), \fIon\fR\|(1) and to blink mode (2). the
red led does not support blinking. returns true on success,
undef on failure.
.IP "\fBswitch_relay( <new_state>)\fR" 4
.IX Item "switch_relay( <new_state>)"
switched relais off (0)
or \fIon\fR\|(1) and returns true on success, undef on failure. 
.IP "\fBbeep( <msec>)\fR" 4
.IX Item "beep( <msec>)"
enables the buzzer for \fBmsec\fR milli seconds.
default beep period is 100 msec.
.IP "\fB\f(BIdouble_beep()\fB\fR" 4
.IX Item "double_beep()"
double beep with a silent phase of 100 msec.
.IP "\fBswitch_buzzer( <new_status>)\fR" 4
.IX Item "switch_buzzer( <new_status>)"
switches the buzzer on (1) or off (0). returns true on
success, undef on failure.
.IP "\fBswitch_transmitter( <new_status>)\fR" 4
.IX Item "switch_transmitter( <new_status>)"
controllers hf-part can be enabled or disabled manually. switching
the transmitter off while in operation is not tested.
returns true on success, undef on failure.
.IP "\fB\f(BIread_inports()\fB\fR" 4
.IX Item "read_inports()"
the controller supports three digital inports. their stat is returned
in a array reference. undef is returned on failure.
.IP "\fBset_controller_address( <new_address>)\fR" 4
.IX Item "set_controller_address( <new_address>)"
set the controller address to <new_address>.
.IP "\fBread_eeprom( <page_num>)\fR" 4
.IX Item "read_eeprom( <page_num>)"
returns the controller internal eeprom page <page_num> as string.
each page consists of 8 byte data. returns undef on failure.
.IP "\fBread_eeprom_block( <block_num>)\fR" 4
.IX Item "read_eeprom_block( <block_num>)"
returns the controller internal eeprom block <block_num> as string.
each block consists of 64 byte data. the maximum block number is 0x1f.
returns undef on failure.
.IP "\fBwrite_eeprom( <page_num>, <data>)\fR" 4
.IX Item "write_eeprom( <page_num>, <data>)"
write <data<gt> into controller internal eeprom page <page_num>.
length(<data>) must be 8 bytes, else function fails.
.IP "\fB\f(BIsave_parameter()\fB\fR" 4
.IX Item "save_parameter()"
save controller state in eeprom.
.IP "\fBset_continuous_mode( 1, <buzzer>, <relais>)\fR" 4
.IX Item "set_continuous_mode( 1, <buzzer>, <relais>)"
enables continuous mode; <buzzer> and <relais> controlls
buzzer and relais activation on transponder detection.
.IP "\fBset_continuous_mode( 0 )\fR" 4
.IX Item "set_continuous_mode( 0 )"
disables continuous mode
.Sp
in continuouse mode the rfid controller looks for transponders and dumps
their uid to serial interface. call \fB\f(BIget_last_ident()\fB\fR to poll these identifiers.
this method clears \fBDevice::Serial\fRs internal read buffer.
.Sp
note: \fB\f(BIget_last_ident()\fB\fR is not implemented. use \fB\f(BIiso_inventory()\fB\fR to watch for
transponders.
.IP "\fBset_baud_rate( <baud_rate>)\fR" 4
.IX Item "set_baud_rate( <baud_rate>)"
sets controllers side serial line speed. needs controller reboot.
.IP "\fB\f(BIread_status()\fB\fR" 4
.IX Item "read_status()"
returns controllers state as structure or undef.
the structure looks like this:
.Sh "\s-1ISO\s0 \s-1RELATED\s0 \s-1FUNCTIONS\s0"
.IX Subsection "ISO RELATED FUNCTIONS"
.IP "\fBiso_inventory( <config_byte>, <afi>, <len>, <mask>)\fR" 4
.IX Item "iso_inventory( <config_byte>, <afi>, <len>, <mask>)"
.RS 4
.RS 4
\&\fBconfig_byte\fR
.Sp
\&\fBafi\fR
.Sp
\&\fBlen\fR
.Sp
\&\fBmask\fR
.RE
.RE
.RS 4
.Sp
on success this method returns an object reference of type
\&\fBRFID::Transponder\fR. 
.RE
.IP "\fBiso_stay_quite( <card> )\fR" 4
.IX Item "iso_stay_quite( <card> )"
\&...
.IP "\fBiso_read_single_block( <card>, <block_num> )\fR" 4
.IX Item "iso_read_single_block( <card>, <block_num> )"
read block <block_num> from transponders memory and return
true on success, undef on failure. read blocks are stored in <card>.
this method stores also information about write protected blocks in <card>,
but it seems to not work with my controller or with texas instruments/philips
tags.
.IP "\fBiso_write_single_block( <card>, <block_num>, <data> )\fR" 4
.IX Item "iso_write_single_block( <card>, <block_num>, <data> )"
write a single block into transponder memory. returns true on success, undef on error.
there might be a problem with locked blocks. on writing to a locked block, the controller
returns an ok. to make really sure the block was written, re-read the block and compare.
.IP "\fBiso_lock_block( <card>, <block_num>)\fR" 4
.IX Item "iso_lock_block( <card>, <block_num>)"
set a permanent write lock on block <block_num>.
.IP "\fBiso_select( <card> )\fR" 4
.IX Item "iso_select( <card> )"
\&...
.IP "\fBiso_reset_to_ready( <card> )\fR" 4
.IX Item "iso_reset_to_ready( <card> )"
\&...
.IP "\fBiso_write_afi( <card>, <new_afi>)\fR" 4
.IX Item "iso_write_afi( <card>, <new_afi>)"
write application family identifier into transponder memory.
the afi is a one byte value.
.IP "\fBiso_lock_afi( <card> )\fR" 4
.IX Item "iso_lock_afi( <card> )"
lock application family identier register on transponder.
.IP "\fBiso_write_dsfid( <card>, <new_dsfid>)\fR" 4
.IX Item "iso_write_dsfid( <card>, <new_dsfid>)"
write data storage format  identifier into transponder memory.
the dsfid is a one byte value.
.IP "\fBiso_lock_dsfid( <card> )\fR" 4
.IX Item "iso_lock_dsfid( <card> )"
lock data storage format identifier register on transponder.
.IP "\fBiso_get_system_information( <card> )\fR" 4
.IX Item "iso_get_system_information( <card> )"
read transponders status flag to detect supported features and
size information. updates <lt>card> and returns true on success.
errors are indicated with undef as return value.
.IP "\fBiso_get_multiblock_sec_status( <card>, <first_block>, <num_blocks> )\fR" 4
.IX Item "iso_get_multiblock_sec_status( <card>, <first_block>, <num_blocks> )"
reads the ro/rw\-flags for up to 16 blocks. security status is updated in <card>.
returns true on success, undef on failure.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
man \fBRFID::Transponder\fR
.PP
man \fBDevice::SerialPort\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Schobert, <martin@weltregierung.de>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004 by Martin Schobert
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
